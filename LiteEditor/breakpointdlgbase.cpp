//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// copyright            : (C) 2014 The CodeLite Team
// file name            : breakpointdlgbase.cpp
//
// -------------------------------------------------------------------------
// A
//              _____           _      _     _ _
//             /  __ \         | |    | |   (_) |
//             | /  \/ ___   __| | ___| |    _| |_ ___
//             | |    / _ \ / _  |/ _ \ |   | | __/ _ )
//             | \__/\ (_) | (_| |  __/ |___| | ||  __/
//              \____/\___/ \__,_|\___\_____/_|\__\___|
//
//                                                  F i l e
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// This file was auto-generated by codelite's wxCrafter Plugin
// wxCrafter project file: breakpointdlg.wxcp
// Do not modify this file by hand!
//////////////////////////////////////////////////////////////////////

#include "breakpointdlgbase.h"


// Declare the bitmap loading function
extern void wxCrafterFrb2RoInitBitmapResources();

static bool bBitmapLoaded = false;


BreakpointTabBase::BreakpointTabBase(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style)
    : wxPanel(parent, id, pos, size, style)
{
    if ( !bBitmapLoaded ) {
        // We need to initialise the default bitmap handler
        wxXmlResource::Get()->AddHandler(new wxBitmapXmlHandler);
        wxCrafterFrb2RoInitBitmapResources();
        bBitmapLoaded = true;
    }
    
    wxBoxSizer* bSizer5 = new wxBoxSizer(wxHORIZONTAL);
    this->SetSizer(bSizer5);
    
    m_listCtrlBreakpoints = new BreakpointsListctrl(this, wxID_ANY, wxDefaultPosition, wxSize(-1, -1), wxLC_SINGLE_SEL|wxLC_REPORT);
    
    bSizer5->Add(m_listCtrlBreakpoints, 1, wxALL|wxEXPAND, 5);
    
    wxBoxSizer* bSizer6 = new wxBoxSizer(wxVERTICAL);
    
    bSizer5->Add(bSizer6, 0, wxTOP|wxEXPAND, 25);
    
    m_buttonAdd = new wxButton(this, wxID_ANY, _("&Add"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_buttonAdd->SetToolTip(_("Add a new breakpoint or watchpoint"));
    
    bSizer6->Add(m_buttonAdd, 0, wxALL, 5);
    
    m_buttonEdit = new wxButton(this, wxID_ANY, _("&Edit"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_buttonEdit->SetToolTip(_("Edit the selected item"));
    
    bSizer6->Add(m_buttonEdit, 0, wxALL, 5);
    
    m_buttonDelete = new wxButton(this, wxID_ANY, _("&Delete"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_buttonDelete->SetToolTip(_("Delete the selected item"));
    
    bSizer6->Add(m_buttonDelete, 0, wxALL, 5);
    
    m_buttonDeleteAll = new wxButton(this, wxID_ANY, _("Delete &All"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_buttonDeleteAll->SetToolTip(_("Delete all breakpoints and watchpoints"));
    
    bSizer6->Add(m_buttonDeleteAll, 0, wxALL, 5);
    
    m_buttonApplyPending = new wxButton(this, wxID_ANY, _("Set Pending"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_buttonApplyPending->SetToolTip(_("If this button is visible, there are breakpoints that you tried to set, but that the debugger refused. This most often happens when the breakpoint is inside a library that hadn't been loaded when the debugger started.\n\nClick to offer the breakpoints to the debugger again."));
    
    bSizer6->Add(m_buttonApplyPending, 0, wxALL, 5);
    
    SetSizeHints(-1,-1);
    if ( GetSizer() ) {
         GetSizer()->Fit(this);
    }
    Centre(wxBOTH);
    // Connect events
    m_listCtrlBreakpoints->Connect(wxEVT_COMMAND_LIST_ITEM_ACTIVATED, wxListEventHandler(BreakpointTabBase::OnItemActivated), NULL, this);
    m_listCtrlBreakpoints->Connect(wxEVT_COMMAND_LIST_ITEM_DESELECTED, wxListEventHandler(BreakpointTabBase::OnItemDeselected), NULL, this);
    m_listCtrlBreakpoints->Connect(wxEVT_COMMAND_LIST_ITEM_RIGHT_CLICK, wxListEventHandler(BreakpointTabBase::OnItemRightClick), NULL, this);
    m_listCtrlBreakpoints->Connect(wxEVT_COMMAND_LIST_ITEM_SELECTED, wxListEventHandler(BreakpointTabBase::OnItemSelected), NULL, this);
    m_buttonAdd->Connect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnAdd), NULL, this);
    m_buttonEdit->Connect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnEdit), NULL, this);
    m_buttonDelete->Connect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnDelete), NULL, this);
    m_buttonDeleteAll->Connect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnDeleteAll), NULL, this);
    m_buttonApplyPending->Connect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnApplyPending), NULL, this);
    
}

BreakpointTabBase::~BreakpointTabBase()
{
    m_listCtrlBreakpoints->Disconnect(wxEVT_COMMAND_LIST_ITEM_ACTIVATED, wxListEventHandler(BreakpointTabBase::OnItemActivated), NULL, this);
    m_listCtrlBreakpoints->Disconnect(wxEVT_COMMAND_LIST_ITEM_DESELECTED, wxListEventHandler(BreakpointTabBase::OnItemDeselected), NULL, this);
    m_listCtrlBreakpoints->Disconnect(wxEVT_COMMAND_LIST_ITEM_RIGHT_CLICK, wxListEventHandler(BreakpointTabBase::OnItemRightClick), NULL, this);
    m_listCtrlBreakpoints->Disconnect(wxEVT_COMMAND_LIST_ITEM_SELECTED, wxListEventHandler(BreakpointTabBase::OnItemSelected), NULL, this);
    m_buttonAdd->Disconnect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnAdd), NULL, this);
    m_buttonEdit->Disconnect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnEdit), NULL, this);
    m_buttonDelete->Disconnect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnDelete), NULL, this);
    m_buttonDeleteAll->Disconnect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnDeleteAll), NULL, this);
    m_buttonApplyPending->Disconnect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointTabBase::OnApplyPending), NULL, this);
    
}

BreakpointPropertiesDlgBase::BreakpointPropertiesDlgBase(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style)
    : wxDialog(parent, id, title, pos, size, style)
{
    if ( !bBitmapLoaded ) {
        // We need to initialise the default bitmap handler
        wxXmlResource::Get()->AddHandler(new wxBitmapXmlHandler);
        wxCrafterFrb2RoInitBitmapResources();
        bBitmapLoaded = true;
    }
    
    wxBoxSizer* bSizer3 = new wxBoxSizer(wxVERTICAL);
    this->SetSizer(bSizer3);
    
    m_staticText9 = new wxStaticText(this, wxID_ANY, _("Select the type of the breakpoint:"), wxDefaultPosition, wxSize(-1, -1), 0);
    
    bSizer3->Add(m_staticText9, 0, wxALL, 5);
    
    m_choicebook = new wxChoicebook(this, wxID_ANY, wxDefaultPosition, wxSize(-1, -1), 0);
    
    bSizer3->Add(m_choicebook, 0, wxALL|wxEXPAND, 5);
    
    m_panel1 = new wxPanel(m_choicebook, wxID_ANY, wxDefaultPosition, wxSize(-1, -1), wxTAB_TRAVERSAL);
    m_choicebook->AddPage(m_panel1, _("Breakpoint"), false);
    
    wxBoxSizer* bSizer14 = new wxBoxSizer(wxVERTICAL);
    m_panel1->SetSizer(bSizer14);
    
    m_staticText51 = new wxStaticText(m_panel1, wxID_ANY, _("Break by line, function or memory address:"), wxDefaultPosition, wxSize(-1, -1), 0);
    
    bSizer14->Add(m_staticText51, 0, wxALL|wxEXPAND, 5);
    
    wxBoxSizer* bSizer111 = new wxBoxSizer(wxVERTICAL);
    
    bSizer14->Add(bSizer111, 1, wxALL|wxEXPAND, 0);
    
    wxFlexGridSizer* fgSizer2 = new wxFlexGridSizer(0, 2, 0, 0);
    fgSizer2->SetFlexibleDirection( wxBOTH );
    fgSizer2->SetNonFlexibleGrowMode( wxFLEX_GROWMODE_SPECIFIED );
    fgSizer2->AddGrowableCol(1);
    
    bSizer111->Add(fgSizer2, 0, wxEXPAND, 5);
    
    m_checkLineno = new wxCheckBox(m_panel1, wxID_ANY, _("Line number"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_checkLineno->SetValue(false);
    
    fgSizer2->Add(m_checkLineno, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5);
    
    m_textLineno = new wxTextCtrl(m_panel1, wxID_ANY, wxT(""), wxDefaultPosition, wxSize(-1, -1), 0);
    m_textLineno->SetToolTip(_("Enter the line-number on which you wish to break. It's assumed to refer to the current file: if it doesn't, please enter the correct filepath below."));
    
    fgSizer2->Add(m_textLineno, 0, wxALL|wxEXPAND, 5);
    
    m_checkBreakFunction = new wxCheckBox(m_panel1, wxID_ANY, _("Function name"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_checkBreakFunction->SetValue(false);
    
    fgSizer2->Add(m_checkBreakFunction, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5);
    
    m_textFunctionname = new wxTextCtrl(m_panel1, wxID_ANY, wxT(""), wxDefaultPosition, wxSize(-1, -1), 0);
    m_textFunctionname->SetToolTip(_("If you wish to break when a particular function is entered, insert its name here. In C just the name will do e.g. 'main' or 'myFoo'. For C++ class methods, you need to do 'MyClass::myFoo'\n\nAlternatively you can enter a regular expression, and tick the checkbox below. A breakpoint will then be set on all matching functions."));
    
    fgSizer2->Add(m_textFunctionname, 0, wxALL|wxEXPAND, 5);
    
    fgSizer2->Add(0, 0, 1, 0, 5);
    
    m_checkRegex = new wxCheckBox(m_panel1, wxID_ANY, _("This is a regex"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_checkRegex->SetValue(false);
    m_checkRegex->SetToolTip(_("If you wish to insert a breakpoint on several functions, you can tick this box, then enter a suitable regular expression in the textctrl above."));
    
    fgSizer2->Add(m_checkRegex, 0, wxALL|wxEXPAND, 5);
    
    m_checkBreakMemory = new wxCheckBox(m_panel1, wxID_ANY, _("Memory address:"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_checkBreakMemory->SetValue(false);
    
    fgSizer2->Add(m_checkBreakMemory, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5);
    
    m_textBreakMemory = new wxTextCtrl(m_panel1, wxID_ANY, wxT(""), wxDefaultPosition, wxSize(-1, -1), 0);
    m_textBreakMemory->SetToolTip(_("To break on a memory address, enter the address here.\ne.g. 0x0a1b2c3d or 12345678"));
    
    fgSizer2->Add(m_textBreakMemory, 1, wxALL|wxEXPAND, 5);
    
    m_staticText6 = new wxStaticText(m_panel1, wxID_ANY, _("In file:"), wxDefaultPosition, wxSize(-1, -1), 0);
    
    fgSizer2->Add(m_staticText6, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5);
    
    wxBoxSizer* bSizer18 = new wxBoxSizer(wxHORIZONTAL);
    
    fgSizer2->Add(bSizer18, 0, wxTOP|wxBOTTOM|wxEXPAND, 5);
    
    m_textFilename = new wxTextCtrl(m_panel1, wxID_ANY, wxT(""), wxDefaultPosition, wxSize(-1, -1), 0);
    m_textFilename->SetToolTip(_("If you've entered a line-number, its assumed to refer to the current file. If it isn't, enter the correct filename here.\n\nFor a function, a file is usually not required. However, if you have several functions with the same name, in several different files (do people _really_ do that?) and you want to break on only one of those, enter the correct filename here."));
    
    bSizer18->Add(m_textFilename, 1, wxALL, 5);
    
    m_buttonBrowse = new wxButton(m_panel1, wxID_ANY, _("Browse"), wxDefaultPosition, wxSize(-1, -1), 0);
    
    bSizer18->Add(m_buttonBrowse, 0, wxALL, 5);
    
    m_staticline5 = new wxStaticLine(m_panel1, wxID_ANY, wxDefaultPosition, wxSize(-1, -1), wxLI_HORIZONTAL);
    
    bSizer14->Add(m_staticline5, 0, wxALL|wxEXPAND, 5);
    
    m_panel2 = new wxPanel(m_choicebook, wxID_ANY, wxDefaultPosition, wxSize(-1, -1), wxTAB_TRAVERSAL);
    m_choicebook->AddPage(m_panel2, _("Watchpoint"), false);
    
    wxBoxSizer* bSizer13 = new wxBoxSizer(wxVERTICAL);
    m_panel2->SetSizer(bSizer13);
    
    wxArrayString m_radioWatchtypeArr;
    m_radioWatchtypeArr.Add(wxT("write only"));
    m_radioWatchtypeArr.Add(wxT("read only"));
    m_radioWatchtypeArr.Add(wxT("read-write"));
    m_radioWatchtype = new wxRadioBox(m_panel2, wxID_ANY, _("Type of watchpoint:"), wxDefaultPosition, wxSize(-1, -1), m_radioWatchtypeArr, 3, wxRA_SPECIFY_ROWS);
    m_radioWatchtype->SetToolTip(_("The usual type of watchpoint is 'write-only': that is, it's triggered whenever the target is changed.\n\nAlternatively you can choose for it to trigger when the target is read from, or either written to or read from."));
    m_radioWatchtype->SetSelection(0);
    
    bSizer13->Add(m_radioWatchtype, 0, wxEXPAND|wxALIGN_CENTER_HORIZONTAL, 5);
    
    m_staticText5 = new wxStaticText(m_panel2, wxID_ANY, _("Data to watch:"), wxDefaultPosition, wxSize(-1, -1), 0);
    
    bSizer13->Add(m_staticText5, 0, wxALL|wxEXPAND, 5);
    
    m_textWatchExpression = new wxTextCtrl(m_panel2, wxID_ANY, wxT(""), wxDefaultPosition, wxSize(-1, -1), wxTE_MULTILINE);
    m_textWatchExpression->SetToolTip(_("Identify the data to be watched. It can be one of:\n1) Any variable name e.g. 'foo'\n2) A memory address, suitably cast e.g.*(int*)0x12345678 will watch an int-sized block starting at this address.\nDon't include spaces in the expression: gdb can't understand them.\n3) A complex expression e.g. a*b + c/d'. The expression can use any operators valid in the program's native language.\n\nNB. A watchpoint set on a local variable will automatically be removed when the variable loses scope."));
    
    bSizer13->Add(m_textWatchExpression, 1, wxALL|wxEXPAND, 5);
    
    wxBoxSizer* bSizer5 = new wxBoxSizer(wxVERTICAL);
    
    bSizer3->Add(bSizer5, 1, wxALL|wxEXPAND, 5);
    
    m_staticText1 = new wxStaticText(this, wxID_ANY, _("Conditional Breaks: Add any condition here"), wxDefaultPosition, wxSize(-1, -1), 0);
    
    bSizer5->Add(m_staticText1, 0, wxALL|wxEXPAND, 5);
    
    m_textCond = new wxTextCtrl(this, wxID_ANY, wxT(""), wxDefaultPosition, wxSize(-1,-1), wxTE_MULTILINE);
    m_textCond->SetToolTip(_("You can add a condition to any breakpoint or watchpoint. The debugger will then stop only if the condition is met.\n\nThe condition can be any simple or complex expression in your programming language,providing it returns a bool. However any variables that you use must be in scope.\n\nIf you've previously set a condition and no longer want it, just clear this textctrl."));
    
    bSizer5->Add(m_textCond, 1, wxALL|wxEXPAND, 5);
    
    m_staticText11 = new wxStaticText(this, wxID_ANY, _("Command List: Add any command(s) here"), wxDefaultPosition, wxSize(-1, -1), 0);
    
    bSizer5->Add(m_staticText11, 0, wxALL|wxEXPAND, 5);
    
    m_textCommands = new wxTextCtrl(this, wxID_ANY, wxT(""), wxDefaultPosition, wxSize(-1, -1), wxTE_MULTILINE);
    m_textCommands->SetToolTip(_("You can add a list of commands to any breakpoint or watchpoint. When the breakpoint is hit and the program interrupted, those commands will be executed.\n\nFor example, to print the value of the variable foo and then continue running the program, enter:\nprint foo\ncont\n\nIf you've previously entered commands, and no longer want them, just clear this textctrl."));
    
    bSizer5->Add(m_textCommands, 1, wxALL|wxEXPAND, 5);
    
    wxFlexGridSizer* fgSizer1 = new wxFlexGridSizer(2, 4, 0, 0);
    fgSizer1->SetFlexibleDirection( wxBOTH );
    fgSizer1->SetNonFlexibleGrowMode( wxFLEX_GROWMODE_SPECIFIED );
    fgSizer1->AddGrowableCol(0);
    fgSizer1->AddGrowableCol(1);
    fgSizer1->AddGrowableCol(2);
    fgSizer1->AddGrowableCol(3);
    
    bSizer5->Add(fgSizer1, 0, wxEXPAND, 5);
    
    m_checkDisable = new wxCheckBox(this, wxID_ANY, _("Disable"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_checkDisable->SetValue(false);
    m_checkDisable->SetToolTip(_("If you check this box, the breakpoint (or watchpoint) will still exist, but it won't trigger. If you uncheck it in the future, the breakpoint will work again."));
    
    fgSizer1->Add(m_checkDisable, 0, wxALL|wxEXPAND|wxALIGN_CENTER_VERTICAL, 5);
    
    m_checkTemp = new wxCheckBox(this, wxID_ANY, _("Make temporary"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_checkTemp->SetValue(false);
    m_checkTemp->SetToolTip(_("A temporary breakpoint (or watchpoint) is one that works only once. When it's hit it behaves like any other, except that it's then deleted."));
    
    fgSizer1->Add(m_checkTemp, 0, wxALL|wxEXPAND|wxALIGN_CENTER_VERTICAL, 5);
    
    m_staticText7 = new wxStaticText(this, wxID_ANY, _("Ignore count:"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_staticText7->SetToolTip(_("Enter a count >0 to ignore this breakpoint (or watchpoint) for that number of times. It then behaves as though it is disabled, except that every time it would have triggered, the ignore count decrements.\nWhen the count reaches zero, the breakpoint becomes active again."));
    
    fgSizer1->Add(m_staticText7, 0, wxALL|wxALIGN_CENTER_VERTICAL, 5);
    
    m_spinIgnore = new wxSpinCtrl(this, wxID_ANY, wxT("0"), wxDefaultPosition, wxSize(-1, -1), wxSP_ARROW_KEYS);
    m_spinIgnore->SetRange(0, 1000000);
    m_spinIgnore->SetValue(0);
    
    fgSizer1->Add(m_spinIgnore, 1, wxALL|wxEXPAND|wxALIGN_CENTER_VERTICAL, 5);
    
    m_staticline4 = new wxStaticLine(this, wxID_ANY, wxDefaultPosition, wxSize(-1, -1), wxLI_HORIZONTAL);
    
    bSizer3->Add(m_staticline4, 0, wxALL|wxEXPAND, 5);
    
    wxBoxSizer* bSizer9 = new wxBoxSizer(wxHORIZONTAL);
    
    bSizer3->Add(bSizer9, 0, wxALIGN_CENTER_HORIZONTAL, 5);
    
    m_button6 = new wxButton(this, wxID_OK, _("&OK"), wxDefaultPosition, wxSize(-1, -1), 0);
    m_button6->SetDefault();
    
    bSizer9->Add(m_button6, 0, wxALL, 5);
    
    m_button7 = new wxButton(this, wxID_CANCEL, _("Cancel"), wxDefaultPosition, wxSize(-1, -1), 0);
    
    bSizer9->Add(m_button7, 0, wxALL, 5);
    
    SetSizeHints(-1,-1);
    if ( GetSizer() ) {
         GetSizer()->Fit(this);
    }
    Centre();
    // Connect events
    m_choicebook->Connect(wxEVT_COMMAND_CHOICEBOOK_PAGE_CHANGED, wxChoicebookEventHandler(BreakpointPropertiesDlgBase::OnPageChanged), NULL, this);
    m_choicebook->Connect(wxEVT_COMMAND_CHOICEBOOK_PAGE_CHANGING, wxChoicebookEventHandler(BreakpointPropertiesDlgBase::OnPageChanging), NULL, this);
    m_checkLineno->Connect(wxEVT_COMMAND_CHECKBOX_CLICKED, wxCommandEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakLineno), NULL, this);
    m_checkLineno->Connect(wxEVT_UPDATE_UI, wxUpdateUIEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakLinenoUI), NULL, this);
    m_checkBreakFunction->Connect(wxEVT_COMMAND_CHECKBOX_CLICKED, wxCommandEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakFunction), NULL, this);
    m_checkBreakFunction->Connect(wxEVT_UPDATE_UI, wxUpdateUIEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakFunctionUI), NULL, this);
    m_checkBreakMemory->Connect(wxEVT_COMMAND_CHECKBOX_CLICKED, wxCommandEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakMemory), NULL, this);
    m_checkBreakMemory->Connect(wxEVT_UPDATE_UI, wxUpdateUIEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakMemoryUI), NULL, this);
    m_buttonBrowse->Connect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointPropertiesDlgBase::OnBrowse), NULL, this);
    
}

BreakpointPropertiesDlgBase::~BreakpointPropertiesDlgBase()
{
    m_choicebook->Disconnect(wxEVT_COMMAND_CHOICEBOOK_PAGE_CHANGED, wxChoicebookEventHandler(BreakpointPropertiesDlgBase::OnPageChanged), NULL, this);
    m_choicebook->Disconnect(wxEVT_COMMAND_CHOICEBOOK_PAGE_CHANGING, wxChoicebookEventHandler(BreakpointPropertiesDlgBase::OnPageChanging), NULL, this);
    m_checkLineno->Disconnect(wxEVT_COMMAND_CHECKBOX_CLICKED, wxCommandEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakLineno), NULL, this);
    m_checkLineno->Disconnect(wxEVT_UPDATE_UI, wxUpdateUIEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakLinenoUI), NULL, this);
    m_checkBreakFunction->Disconnect(wxEVT_COMMAND_CHECKBOX_CLICKED, wxCommandEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakFunction), NULL, this);
    m_checkBreakFunction->Disconnect(wxEVT_UPDATE_UI, wxUpdateUIEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakFunctionUI), NULL, this);
    m_checkBreakMemory->Disconnect(wxEVT_COMMAND_CHECKBOX_CLICKED, wxCommandEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakMemory), NULL, this);
    m_checkBreakMemory->Disconnect(wxEVT_UPDATE_UI, wxUpdateUIEventHandler(BreakpointPropertiesDlgBase::OnCheckBreakMemoryUI), NULL, this);
    m_buttonBrowse->Disconnect(wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler(BreakpointPropertiesDlgBase::OnBrowse), NULL, this);
    
}
